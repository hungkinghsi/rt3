<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Chapter 5: Advanced Types</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part357.htm">&lt; Previous</a><span> | </span><a href="../Learn+React+with+TypeScript+3.htm">Contents</a><span> | </span><a href="part359.htm">Next &gt;</a></p><h3 style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><a name="bookmark960">Chapter 5: Advanced Types</a><a name="bookmark972">&zwnj;</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">1. We have an interface that represents a course result as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 79pt;text-indent: -10pt;line-height: 120%;text-align: left;">interface ICourseMark { courseName: string; grade: string;</p><p class="s12" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 50pt;text-indent: 0pt;text-align: left;">We can use this interface as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 79pt;text-indent: -10pt;line-height: 120%;text-align: left;">const geography: ICourseMark = { courseName: &quot;Geography&quot;, grade: &quot;B&quot;</p><p class="s12" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 50pt;text-indent: 0pt;line-height: 89%;text-align: left;">The grades can only be A, B, C, or D. How can we create a stronger typed version of the <span class="s22">grade </span>property in this interface?</p><p style="padding-top: 8pt;padding-left: 53pt;text-indent: 0pt;text-align: left;">We can use a union type:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 101pt;text-indent: -10pt;line-height: 120%;text-align: left;">interface ICourseMark { courseName: string;</p><p class="s12" style="padding-left: 101pt;text-indent: 0pt;line-height: 10pt;text-align: left;">grade: <span class="s21">&quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot;</span>;</p><p class="s12" style="padding-top: 1pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 53pt;text-indent: -13pt;line-height: 89%;text-align: left;">2. We have the following functions, which validate that numbers and strings are populated with a value:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 79pt;text-indent: -10pt;line-height: 120%;text-align: left;">function isNumberPopulated(field: number): boolean { return field !== null &amp;&amp; field !== undefined;</p><p class="s12" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">function isStringPopulated(field: string): boolean {</p><p class="s12" style="padding-top: 1pt;padding-left: 79pt;text-indent: 0pt;text-align: left;">return field !== null &amp;&amp; field !== undefined &amp;&amp; field !== &quot;&quot;;</p><p class="s12" style="padding-top: 1pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 50pt;text-indent: 0pt;line-height: 94%;text-align: left;">How can we combine these into a single function called <span class="s22">isPopulated </span>with signature overloads?</p><p style="padding-top: 8pt;padding-left: 50pt;text-indent: 0pt;line-height: 94%;text-align: left;">We can use overload signatures and then a union type for <span class="s22">field </span>in the main function. We can then use the <span class="s22">typeof </span>type guard in the function to deal with the different branches of logic:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 68pt;text-indent: 0pt;line-height: 120%;text-align: left;">function isPopulated(field: number): boolean function isPopulated(field: string): boolean</p><p class="s12" style="padding-left: 74pt;text-indent: -5pt;line-height: 120%;text-align: left;">function isPopulated(field: number | string): boolean { if (typeof field === &quot;number&quot;) {</p><p class="s12" style="padding-left: 74pt;text-indent: 0pt;text-align: left;">return field !== null &amp;&amp; field !== undefined;</p><p class="s12" style="padding-top: 1pt;padding-left: 74pt;text-indent: 0pt;text-align: left;">} else {</p><p class="s12" style="padding-top: 1pt;padding-left: 74pt;text-indent: 0pt;text-align: left;">return field !== null &amp;&amp; field !== undefined &amp;&amp; field !== &quot;&quot;;</p><p class="s12" style="padding-top: 1pt;padding-left: 74pt;text-indent: 0pt;text-align: left;">}</p><p class="s12" style="padding-top: 1pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 53pt;text-indent: -13pt;line-height: 94%;text-align: left;">3. How can we implement a more flexible version of the <span class="s22">isPopulated </span>function with generics?</p><p style="padding-top: 8pt;padding-left: 50pt;text-indent: 2pt;line-height: 94%;text-align: left;">We can use a generic function with a <span class="s22">typeof </span>type guard for the special branch of code for strings:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 79pt;text-indent: -10pt;line-height: 120%;text-align: left;">function isPopulated&lt;T&gt;(field: T): boolean { if (typeof field === &quot;string&quot;) {</p><p class="s12" style="padding-left: 90pt;text-indent: 0pt;text-align: left;">return field !== null &amp;&amp; field !== undefined &amp;&amp; field !== &quot;&quot;;</p><p class="s12" style="padding-top: 1pt;padding-left: 79pt;text-indent: 0pt;text-align: left;">} else {</p><p class="s12" style="padding-top: 1pt;padding-left: 90pt;text-indent: 0pt;text-align: left;">return field !== null &amp;&amp; field !== undefined;</p><p class="s12" style="padding-top: 1pt;padding-left: 79pt;text-indent: 0pt;text-align: left;">}</p><p class="s12" style="padding-top: 1pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">4. We have the follow type alias of stages:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 79pt;text-indent: -10pt;line-height: 120%;text-align: left;">type Stages = { pending: &#39;Pending&#39;, started: &#39;Started&#39;,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 79pt;text-indent: 0pt;text-align: left;">completed: &#39;Completed&#39;,</p><p class="s12" style="padding-top: 1pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 50pt;text-indent: 0pt;line-height: 94%;text-align: left;">How can we programmatically turn this into the union type <span class="s22">&#39;Pending&#39; | &#39;Started&#39; | &#39;Completed&#39;</span>?</p><p style="padding-top: 8pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">We can use the <span class="s22">keyof </span>keyword:</p><p class="s12" style="padding-top: 9pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">type StageUnion = keyof Stages</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">5. We have the following union type:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">type Grade = &#39;gold&#39; | &#39;silver&#39; | &#39;bronze&#39;;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 50pt;text-indent: 0pt;text-align: left;">How can we programmatically create the following type?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 79pt;text-indent: -10pt;line-height: 120%;text-align: left;">type GradeMap = { gold: string; silver: string; bronze: string</p><p class="s12" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 50pt;text-indent: 0pt;text-align: left;">We can map the type as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">type GradeMap = { [P in Grade]: string }</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part357.htm">&lt; Previous</a><span> | </span><a href="../Learn+React+with+TypeScript+3.htm">Contents</a><span> | </span><a href="part359.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>

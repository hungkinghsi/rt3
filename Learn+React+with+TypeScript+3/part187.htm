<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Discriminated union pattern</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part186.htm">&lt; Previous</a><span> | </span><a href="../Learn+React+with+TypeScript+3.htm">Contents</a><span> | </span><a href="part188.htm">Next &gt;</a></p><h4 style="padding-left: 5pt;text-indent: 0pt;text-align: left;"><a name="bookmark469">Discriminated union pattern</a></h4><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;line-height: 152%;text-align: left;">The discriminated union pattern allows us to handle the logic for different union types. Let&#39;s go through an example:</p><p style="padding-top: 1pt;padding-left: 53pt;text-indent: -13pt;line-height: 89%;text-align: left;">1. Let&#39;s first create three interfaces to represent a textbox, a date picker, and a number slider:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 79pt;text-indent: -10pt;line-height: 120%;text-align: left;">interface ITextbox { control: &quot;Textbox&quot;; value: string; multiline: boolean;</p><p class="s12" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 79pt;text-indent: -10pt;line-height: 120%;text-align: left;">interface IDatePicker { control: &quot;DatePicker&quot;; value: Date;</p><p class="s12" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 79pt;text-indent: -10pt;line-height: 120%;text-align: left;">interface INumberSlider { control: &quot;NumberSlider&quot;; value: number;</p><p class="s12" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 50pt;text-indent: 0pt;line-height: 94%;text-align: left;"><a name="bookmark470">They all have a property called </a><span class="s22">control</span>, which will be the discriminant in the pattern.</p><p style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">2. Let&#39;s move on to combine these interfaces into a union type called <span class="s22">Field</span>:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-top: 5pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">type Field = ITextbox | IDatePicker | INumberSlider;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 50pt;text-indent: 0pt;line-height: 89%;text-align: left;">So, we can create union types from any types, and not just string literals. In this case, we have created a union type from three interfaces.</p><p style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">3. Let&#39;s now create a function to initialize the value in the <span class="s22">Field </span>type:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-top: 5pt;padding-left: 79pt;text-indent: -10pt;line-height: 120%;text-align: left;">function intializeValue(field: Field) { switch (field.control) {</p><p class="s12" style="padding-left: 101pt;text-indent: -10pt;line-height: 120%;text-align: left;">case &quot;Textbox&quot;: field.value = &quot;&quot;; break;</p><p class="s12" style="padding-left: 101pt;text-indent: -10pt;line-height: 120%;text-align: left;">case &quot;DatePicker&quot;: field.value = new Date(); break;</p><p class="s12" style="padding-left: 101pt;text-indent: -10pt;line-height: 120%;text-align: left;">case &quot;NumberSlider&quot;: field.value = 0; break;</p><p class="s12" style="padding-left: 90pt;text-indent: 0pt;text-align: left;">default:</p><p class="s12" style="padding-top: 1pt;padding-left: 101pt;text-indent: 0pt;text-align: left;">const shouldNotReach: never = field;</p><p class="s12" style="padding-top: 1pt;padding-left: 79pt;text-indent: 0pt;text-align: left;">}</p><p class="s12" style="padding-top: 1pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 50pt;text-indent: 0pt;line-height: 94%;text-align: left;">The value we need to set depends on the discriminant property, <span class="s22">control</span>. So, we have used a <span class="s22">switch </span>statement to branch on this property.</p><p style="padding-top: 8pt;padding-left: 50pt;text-indent: 0pt;line-height: 94%;text-align: left;">The <span class="s22">default </span>branch in the <span class="s22">switch </span>statement is where things get interesting. This branch should never be reached, so we have put a statement with the <span class="s22">never </span>type in that branch. We&#39;ll see the value of doing this after the next steps.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 53pt;text-indent: -13pt;line-height: 89%;text-align: left;">4. Let&#39;s pretend time has passed and we have a new requirement for checkbox fields. Let&#39;s implement an interface for this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 79pt;text-indent: -10pt;line-height: 120%;text-align: left;">interface ICheckbox { control: &quot;Checkbox&quot;; value: boolean;</p><p class="s12" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">5. Let&#39;s also add this to the union <span class="s22">Field </span>type:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-top: 5pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">type Field = ITextbox | IDatePicker | INumberSlider | ICheckbox;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 50pt;text-indent: 0pt;line-height: 94%;text-align: left;">We&#39;ll immediately see that our <span class="s22">initializeValue </span>function throws a compilation error on the <span class="s22">never </span>declaration:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 53pt;text-indent: 0pt;text-align: left;"><span><img width="442" height="229" alt="image" src="Image_271.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 50pt;text-indent: 0pt;line-height: 94%;text-align: left;">This is very valuable because the <span class="s22">never </span>statement ensures we don&#39;t forget to add a branch of code for the new checkbox requirement.</p><p style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">6. So, let&#39;s go and implement this additional branch for the <span class="s22">&quot;Checkbox&quot; </span>field:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-top: 5pt;padding-left: 79pt;text-indent: -10pt;line-height: 120%;text-align: left;">function intializeValue(field: Field) { switch (field.control) {</p><p class="s12" style="padding-left: 101pt;text-indent: -10pt;line-height: 120%;text-align: left;">case &quot;Textbox&quot;: field.value = &quot;&quot;; break;</p><p class="s12" style="padding-left: 101pt;text-indent: -10pt;line-height: 120%;text-align: left;">case &quot;DatePicker&quot;: field.value = new Date(); break;</p><p class="s12" style="padding-left: 101pt;text-indent: -10pt;line-height: 120%;text-align: left;">case &quot;NumberSlider&quot;: field.value = 0; break;</p><p class="s21" style="padding-left: 101pt;text-indent: -10pt;line-height: 106%;text-align: left;">case &quot;Checkbox&quot;: field.value = false; break;</p><p class="s12" style="padding-left: 90pt;text-indent: 0pt;text-align: left;">default:</p><p class="s12" style="padding-top: 1pt;padding-left: 101pt;text-indent: 0pt;text-align: left;">const shouldNotReach: never = field;</p><p class="s12" style="padding-top: 1pt;padding-left: 79pt;text-indent: 0pt;text-align: left;">}</p><p class="s12" style="padding-top: 1pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;line-height: 90%;text-align: left;"><a name="bookmark447">So, union types allow us to combine any types together to form another type. This allows us to create stricter types, particularly when working with strings. The discriminated union pattern allows us to have branches of logic for different types in the union, and the </a><span class="s22">never </span>type helps us catch all the changes that need to happen when we add a new type into the union type.<a name="bookmark471">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part186.htm">&lt; Previous</a><span> | </span><a href="../Learn+React+with+TypeScript+3.htm">Contents</a><span> | </span><a href="part188.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>

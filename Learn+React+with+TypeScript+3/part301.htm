<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Summary</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part300.htm">&lt; Previous</a><span> | </span><a href="../Learn+React+with+TypeScript+3.htm">Contents</a><span> | </span><a href="part302.htm">Next &gt;</a></p><h3 style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><a name="bookmark748">Summary</a><a name="bookmark808">&zwnj;</a></h3><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;line-height: 89%;text-align: left;">Callback-based asynchronous code can be difficult to read and maintain. Who&#39;s spent hours trying to track down the root cause of a bug in callback-based asynchronous code? Or just spent hours trying to understand what a piece of callback-based asynchronous code is trying to do? Thankfully, we now have alternative ways of writing asynchronous code.</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;line-height: 91%;text-align: left;">Promise-based functions are a great improvement over callback-based asynchronous code because the code is a lot more readable and errors can be handled more easily. The <span class="s22">async </span>and <span class="s22">await </span>keywords arguably make reading asynchronous code even easier than promised-based function code because it is very close to what the synchronous equivalent would look like.</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;line-height: 91%;text-align: left;">Modern browsers have a nice function called <span class="s22">fetch </span>for interacting with REST APIs. This is a promised-based function allowing us to easily make a request and nicely manage the response.</p><p class="s22" style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;line-height: 91%;text-align: left;">axios <span class="p">is a popular alternative to </span>fetch<span class="p">. The API is arguably cleaner and allows us to better handle HTTP error codes. Timeouts and canceling requests are also made very simple  using </span>axios<span class="p">. </span>axios <span class="p">is also TypeScript-friendly, having types baked into the library.</span></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 14pt;text-align: left;">Having played with both <span class="s22">axios </span>and <span class="s22">fetch</span>, which is your favorite?</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 91%;text-align: left;">We can interact with REST APIs in both class- and function-based components. When calling a REST API to get data to display in a first component render, we need to wait until just after the component has been mounted. In class components, we do this using the <span class="s22">componentDidMount </span>life cycle method. In function components, we do this using the <span class="s22">useEffect </span>function, passing an empty array as the second parameter. Having experienced interacting with REST APIs in both types of components, which component type are you going to use on your next React and TypeScript project?</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;line-height: 89%;text-align: justify;">REST APIs aren&#39;t the only type of API we are likely going to need to interact with. GraphQL is a popular alternative API server. We&#39;ll learn how we can interact with GraphQL servers in the next chapter.</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part300.htm">&lt; Previous</a><span> | </span><a href="../Learn+React+with+TypeScript+3.htm">Contents</a><span> | </span><a href="part302.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>

<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Summary</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part349.htm">&lt; Previous</a><span> | </span><a href="../Learn+React+with+TypeScript+3.htm">Contents</a><span> | </span><a href="part351.htm">Next &gt;</a></p><h3 style="padding-left: 5pt;text-indent: 0pt;text-align: left;"><a name="bookmark951">Summary</a></h3><p style="padding-top: 3pt;padding-left: 5pt;text-indent: 0pt;line-height: 91%;text-align: left;">In this chapter, we learned how to test pure functions written in TypeScript using Jest. We simply execute the function with the parameters we want to test, and use Jest&#39;s <span class="s22">expect </span>function chained with one of Jest&#39;s matcher functions, such as <span class="s22">toBe</span>, to validate the result.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 89%;text-align: left;">We looked at how to interact with Jest&#39;s test runner, and how to apply filters so that only the tests we are focusing on are executed. We learned that testing React and TypeScript components is more involved than testing pure functions, but Jest and react-testing- library give us a great deal of help.</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;line-height: 94%;text-align: left;">We also learned how to render a component using the <span class="s22">render </span>function, and how to interact with and inspect elements using various functions such as <span class="s22">getByText </span>and <span class="s22">getLabelByText </span>from react-testing-library.</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;line-height: 13pt;text-align: left;">We learned that we can easily test asynchronous interactions using the</p><p class="s22" style="padding-left: 5pt;text-indent: 0pt;line-height: 91%;text-align: left;">waitForElement <span class="p">function in react-testing-library as well. We now understand the benefit of not referencing implementation details in our tests, which will help us build more robust tests.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 89%;text-align: left;">We also discussed Jest&#39;s clever snapshot testing tool. We looked at how these tests can regularly break, but also why they are incredibly easy to create and change.</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;line-height: 89%;text-align: left;">The ability to mock and spy into functions is another great Jest feature we now know about. Checking that functions for component event handlers have been called with the right parameters can really add value to our tests.</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;line-height: 91%;text-align: left;">We discussed the <span class="s22">axios-mock-adapter </span>library which we can use for mocking <span class="s22">axios </span>REST API requests. This allows us to easily test container components that interact with RESTful APIs.</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;line-height: 91%;text-align: left;">We now know how to quickly identify the additional tests that we need to implement to give us confidence that our app is well-tested. We created an <span class="s22">npm </span>script command to enable us to do this, using <span class="s22">react-scripts </span>and the <span class="s22">--coverage </span>option.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 89%;text-align: left;">Overall, we now have the knowledge and the tools to robustly create unit tests for our apps with Jest.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;line-height: 90%;text-align: left;">Jasmine and Mocha are two popular alternative testing frameworks to Jest. The big advantage of Jest is that it is configured by <span class="s22">create-react-app </span>to work out the box. We would have to configure Jasmine and Mocha manually if we wanted to use them. Jasmine and Mocha are worth considering, though, if your team is already experienced with either of these tools, rather than learning another testing framework.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 89%;text-align: left;"><a name="bookmark914">Enzyme is another popular library used with Jest to test React apps. It supports shallow rendering, which is a way of rendering only the top-level elements in a component and not child components. It is well worth exploring, but remember that the more we mock, the further from the truth we get, and the less confidence we have that our app is well-tested.</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part349.htm">&lt; Previous</a><span> | </span><a href="../Learn+React+with+TypeScript+3.htm">Contents</a><span> | </span><a href="part351.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
